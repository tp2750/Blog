# Music Synthesis Functions
TP, 2024-10-13

# Conclusions

* G-major chord is the same frequencies as the tonica of G major key and the dominant of C major key.
* G-minor chord is not the same frequencies in G major key and C major key.

# Terms
* Note: pitch number, duration (fraction of beat), volume (relative)
* Tone: frequency, phase. Remember note.
* Tempo: seconds per beat. 90 bpm == 2/3 seconds per beat
* Pulse: periodic function used to generate tone
* Voice: Sequence of notes played on an instrument in a tempo
* Instrument: Pulse, Tuning, Envelope.
* Envelope: Shape of a single tone. May extend the tone to after "note off"
* Tuning: mapping from notes and key to frequencies.
* Sound: function, duration in seconds
* Key: root pich and root frequency. 

## Notation

* C4[0, 4, 7]  == "C E G"
* C4[-5, 0, 4] == "G3 C4 E4" == G3[0, 5, 9]

They would still be rendered as separate voices.

Normal key is Key(60, 261.6255653005986).
A math key could be Key(64, 256) same as Key(4,8).

# Guiding example

Change G major triad from inverted Dominant in key C major c(-5, -1, 2) to Tonica in G key G major g(0, 4, 7). 
In equal temperement these are equal. In just intonation they are slightly different (I think).
Note: They are not different, but other chords are. Eg Gm.

Also: Play a C major triad in normal orientation (0, 4, 7), and inversions (-5, 0, 4), (-8, -5, 0), (-8, 0, 7) in just intonation.

# Overall idea

I want to be able to exchange every part of the processing pipeline: tuning system, generating pulse, envelope, tempo, key.

I want to keep working with functions as long as possible. 
Ideally, the rendering is just applying one function to the vector of sample timepoints.

One approach is to split the "song" into short intervals where each voice is a simple function. 
Then these "voice functions" can be added, and the final funcion can be rendered over that "time slice".
Then the full song is generated by concatenating thses sampled "sound bites".

Start by focusing on rendering to wav. 
Later think Linnstrument.
We should look at MIDI 2.0 and see what to learn. But understand the problems first.
Synchronization between voices is also a MIDI thing.

I think matching the phase between tones is key to not get clicks.

# Pipeline

* Input:
  - phrase: vector of Notes
  - Instrument
  - Tempo
* Output: Voice
  - vector of Sounds
  - vector of start times

We can apply effects to voices.
We can mix voices to a "song".
It can also be masered into channels.

Ideally we should not sample until after the matering. 
Then we sample the individual channles.

  
## Obs
Thee is no +(function, function) method.
So I need to wrap these "voice bites" in a struct to be able to add them.

# New insights: use of phase
I think it is important to adjust the phase so that the transition between sounds is continuous (and possiblt also continuous derivative).
We can acheive this by adjusting the phase of the tone to match the phase of the previous tone, where that ended.
The phase at the end of the tone depends on the frequency, tempo and phase at the beginning of the tone.
We only need to store the phase at the beginning. We can then compute the phase at the end based on frequency and tempo.
The tempo is needed as that determines the number of periods of the tone in a beat.



# Structs and methods

## Note
- pitch::Int # pich number
- duration::T # fraction of beat
- volume::Float32 # relative volume. Default 1.0

## Tone
- frequncy::float32
- phase::float32
- note::Note

### Comments
- Frequency depends of note, tuning and key.
- phase depends on frequency and tempo

## Instrument
- pulse::Pulse
- tuning
- envelope


## play
play(instrument, notes, tempo)

# Envelope

## ADSR: Attac, Decay, Sustain, Release
4 parameters:
- attac: fraction of beat needed to get from volume at end of previous tone (note.volume*sustain[previous note]) to volume of this tone (note.volume)
- decay: fraction of note needed to reach end volume: note.volume*sustain
- sustain: fraction of volume at sustain time
- release: fraction of next beat needed for this tone to go to volume 0

On time axes: note-on, attac,      decay,   note-off, release
On volume axes:    v0,    v1, v1*sustain, v1*sustain, 0

# Proof of concept using TuningSystems

## Change of key

``` julia
using TuningSystems
C1 = "C4 E4 G4" # 0, 4, 7
G1 = "G3 B3 D4" # -5, -1, 2 (dominant), 0, 4, 7 (tonica)

julia> ENV["JULIA_DEBUG"] = TuningSystems
TuningSystems

julia> tns(G1, tuning=just)
# ┌ Debug: pitch=55, octave=-1, scale index=8, scaling=3//2, frequency=196.21917397544897
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# ┌ Debug: pitch=59, octave=-1, scale index=12, scaling=15//8, frequency=245.2739674693112
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# ┌ Debug: pitch=62, octave=0, scale index=3, scaling=9//8, frequency=294.32876096317347
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# 3-element Vector{TuningSystems.Tone}:
#  TuningSystems.Tone(196.21917397544897, 0.0, 1.0, 1.0)
#  TuningSystems.Tone(245.2739674693112, 0.0, 1.0, 1.0)
#  TuningSystems.Tone(294.32876096317347, 0.0, 1.0, 1.0)

julia> tns(G1, tuning = just, root_number=55, root_frequency = 196.21917397544897)
# ┌ Debug: pitch=55, octave=0, scale index=1, scaling=1//1, frequency=196.21917397544897
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# ┌ Debug: pitch=59, octave=0, scale index=5, scaling=5//4, frequency=245.2739674693112
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# ┌ Debug: pitch=62, octave=0, scale index=8, scaling=3//2, frequency=294.32876096317347
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# 3-element Vector{TuningSystems.Tone}:
#  TuningSystems.Tone(196.21917397544897, 0.0, 1.0, 1.0)
#  TuningSystems.Tone(245.2739674693112, 0.0, 1.0, 1.0)
#  TuningSystems.Tone(294.32876096317347, 0.0, 1.0, 1.0)

```

This is the same because the just intonation is symmetric around the trinitus.
All tunings are symmetric if we allow for a difference between 8 and -8 (the two different tritonous).

Does this scaling hold for all intervals or are the major triad just "nice"?

It is indeed because the major triad is "nice".

``` julia
using TuningSystems
Gm = "G3 Bb3 D4"

julia> tns(Gm, tuning=just)
# ┌ Debug: pitch=55, octave=-1, scale index=8, scaling=3//2, frequency=196.21917397544897
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# ┌ Debug: pitch=58, octave=-1, scale index=11, scaling=16//9, frequency=232.55605804497654
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# ┌ Debug: pitch=62, octave=0, scale index=3, scaling=9//8, frequency=294.32876096317347
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# 3-element Vector{TuningSystems.Tone}:
#  TuningSystems.Tone(196.21917397544897, 0.0, 1.0, 1.0)
#  TuningSystems.Tone(232.55605804497654, 0.0, 1.0, 1.0)
#  TuningSystems.Tone(294.32876096317347, 0.0, 1.0, 1.0)

julia> tns(Gm, tuning = just, root_number=55, root_frequency = 196.21917397544897)
# ┌ Debug: pitch=55, octave=0, scale index=1, scaling=1//1, frequency=196.21917397544897
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# ┌ Debug: pitch=58, octave=0, scale index=4, scaling=6//5, frequency=235.46300877053875
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# ┌ Debug: pitch=62, octave=0, scale index=8, scaling=3//2, frequency=294.32876096317347
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# 3-element Vector{TuningSystems.Tone}:
#  TuningSystems.Tone(196.21917397544897, 0.0, 1.0, 1.0)
#  TuningSystems.Tone(235.46300877053875, 0.0, 1.0, 1.0)
#  TuningSystems.Tone(294.32876096317347, 0.0, 1.0, 1.0)
```

They also sound diffeerent:

``` julia
julia> play(s( tns(Gm, tuning=just)))
julia> play(s(tns(Gm, tuning = just, root_number=55, root_frequency = 196.21917397544897)))
```

The last is close to tet12:

``` julia
julia> play(s( tns(Gm, tuning=just)))
# ┌ Debug: pitch=55, octave=-1, scale index=8, scaling=3//2, frequency=196.21917397544897
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# ┌ Debug: pitch=58, octave=-1, scale index=11, scaling=16//9, frequency=232.55605804497654
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# ┌ Debug: pitch=62, octave=0, scale index=3, scaling=9//8, frequency=294.32876096317347
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38

julia> play(s(tns(Gm, tuning = just, root_number=55, root_frequency = 196.21917397544897)))
# ┌ Debug: pitch=55, octave=0, scale index=1, scaling=1//1, frequency=196.21917397544897
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# ┌ Debug: pitch=58, octave=0, scale index=4, scaling=6//5, frequency=235.46300877053875
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# ┌ Debug: pitch=62, octave=0, scale index=8, scaling=3//2, frequency=294.32876096317347
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38

julia> play(s( tns(Gm, tuning=tet12)))
# ┌ Debug: pitch=55, octave=-1, scale index=8, scaling=1.498307076876682, frequency=195.9977179908747
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# ┌ Debug: pitch=58, octave=-1, scale index=11, scaling=1.7817974362806794, frequency=233.08188075904505
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38
# ┌ Debug: pitch=62, octave=0, scale index=3, scaling=1.122462048309373, frequency=293.6647679174076
# └ @ TuningSystems ~/github/tp2750/TuningSystems.jl/src/play.jl:38


```

But Gm does not have the same dual interpretation as Tonica and Dominant.

We can see it simply like this:

``` julia
julia> pitch_class(just.scalings[2]/just.scalings[1])
16//15

julia> pitch_class(just.scalings[3]/just.scalings[2])
135//128
```

Whereas it repeats above the fifth

``` julia
julia> pitch_class(just.scalings[9]/just.scalings[8])
16//15
```

Generally

``` julia
julia> [pitch_class(just.scalings[i+1]/just.scalings[i]) for i = 1:9]
9-element Vector{Rational{Int64}}:
  16//15
 135//128
  16//15
  25//24
  16//15
 135//128
  16//15
  16//15
  25//24

julia> [pitch_class(just.scalings[i+7]/just.scalings[i]) for i = 1:5]
5-element Vector{Rational{Int64}}:
  3//2
  3//2
 40//27
 40//27
  3//2

julia> [pitch_class(just.scalings[i+5]/just.scalings[i]) for i = 1:7]
7-element Vector{Rational{Int64}}:
   4//3
 675//512
   4//3
   4//3
   4//3
   4//3
   4//3

julia> [pitch_class(just.scalings[i+4]/just.scalings[i]) for i = 1:8]
8-element Vector{Rational{Int64}}:
   5//4
   5//4
   5//4
   5//4
  32//25
   5//4
 512//405
   5//4

```

## Inversion

``` julia
using TuningSystems

C1 = "C4 E4 G4"
Cg = "G3 C4 E4"

tns(C1)
# 3-element Vector{TuningSystems.Tone}:
#  TuningSystems.Tone(261.6255653005986, 0.0, 1.0, 1.0)
#  TuningSystems.Tone(329.62755691287, 0.0, 1.0, 1.0)
#  TuningSystems.Tone(391.9954359817494, 0.0, 1.0, 1.0)

tns(Cg)
# 3-element Vector{TuningSystems.Tone}:
#  TuningSystems.Tone(195.9977179908747, 0.0, 1.0, 1.0)
#  TuningSystems.Tone(261.6255653005986, 0.0, 1.0, 1.0)
#  TuningSystems.Tone(329.62755691287, 0.0, 1.0, 1.0)

```
